Caso de uso - Executar comandos SQL
Ator: Usuário do banco
Objetivo: Efetuar alterações na base ou seus dados
Pré-condições: Base criada e definida para execução dos comandos
Pós-condições: Base alterada de acordo com as instruções SQL

Cenário principal:
01. Usuário digita comandos SQL
02. Usuário submete comandos para execução
03. Interface submete código do usuário para a instância do JsonDb
04. JsonDb submete código para o SqlParser
05. SqlParser reconhece os comandos SQL e cria os respectivos objetos de *Statement
06. SqlParser cria retorna a lista de comandos reconhecidos
07. Para cada comando a ser executado:
08. JsonDb solicita o metadado da tabela envolvida na operação
09. Store localiza e retorna o metadado solicitado, já verificando se a tabela existe
10. JsonDb valida os campos e tipos de dados
11. JsonDb verifica se há conflitos com índices
12. JsonDb cria objetos representando as ações que serão efetuadas para o comando
13. JsonDb guarda os objetos de ações na sessão e submete alterações para o store
14. Store executa e retorna o resultado das ações
15. JsonDb cria objeto de resultados do comando e guarda na sessão
16. Se houver mais um comando, pula para este e volta ao passo 04
17. JsonDb descarta os objetos de ações
18. JsonDb retorna os objetos de resultados para a interface
19. Interface define a melhor forma de exibir os resultados

Cenário de exceção:
No passo 05, caso seja identificado algum erro léxico ou sintático:
05.01 SqlParser lança exceção indicando a linha do erro e uma mensagem de diagnóstico
05.02 Interface captura o erro e apresenta a mensagem de diagnóstico para o usuário
05.03 O caso de uso é encerrado

Cenário de exceção:
No passo 09, caso o Store não consiga localizar o metadado:
09.01 Store lança exceção de tabela não encontrada
09.02 JsonDb captura a exceção e cria uma nova, indicando o comando que apresentou problema e uma mensagem de diagnóstico
09.03 JsonDb recupera os objetos de ações já realizadas na sessão
09.04 JsonDb desfaz as ações realizadas na ordem contrária a qual foram feitas
09.05 JsonDb lança a exceção criada no passo 09.02
09.06 Interface captura o erro e apresenta a mensagem de diagnóstico para o usuário
09.07 O caso de uso é encerrado

Cenário de exceção:
No passo 10, caso um campo não exista ou seja de tipo incompatível com o valor fornecido:
10.01 JsonDb cria exceção indicando o comando que apresenta erro e uma mensagem de diagnóstico
10.02 JsonDb recupera os objetos de ações já realizadas na sessão
10.03 JsonDb desfaz as ações realizadas na ordem contrária a qual foram feitas
10.04 JsonDb lança a exceção criada no passo 09.02
10.05 Interface captura o erro e apresenta a mensagem de diagnóstico para o usuário
10.06 O caso de uso é encerrado

Cenário de exceção:
No passo 11, caso seja uma tentativa de inserir um índice duplicado:
11.01 JsonDb cria exceção indicando o comando que apresenta erro e uma mensagem de diagnóstico
11.02 JsonDb recupera os objetos de ações já realizadas na sessão
11.03 JsonDb desfaz as ações realizadas na ordem contrária a qual foram feitas
11.04 JsonDb lança a exceção criada no passo 09.02
11.05 Interface captura o erro e apresenta a mensagem de diagnóstico para o usuário
11.06 O caso de uso é encerrado

Cenário de exceção:
No passo 14, caso ocorra algum erro de IO:
14.01 Store lança exceção indicando a causa do problema e o artefato afetado
14.02 JsonDb cria uma nova exceção indicando a mensagem do erro e o comando afetado
14.03 JsonDb recupera os objetos de ações já realizadas na sessão
14.04 JsonDb desfaz as ações realizadas na ordem contrária a qual foram feitas
14.05 JsonDb lança a exceção criada no passo 09.02
14.06 Interface captura o erro e apresenta a mensagem de diagnóstico para o usuário
14.07 O caso de uso é encerrado
